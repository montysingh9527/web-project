#### Webpack 打包原理

> Webpack 是一个模块打包器，它从一个入口出发，递归地构建模块依赖图，然后将所有模块打包成浏览器可运行的静态资源。

- 1、**初始化**（读取配置webpack.config.js）
  - 加载配置文件（`webpack.config.js`）
  - 合并默认配置
  - 创建Compiler实例
- 2、**从 Entry 开始构建模块依赖图**（确定入口entry）
  - 以配置的 `entry` 文件为起点（例如 `src/main.js`）
  - 递归地分析 `import` 或 `require` 的每个依赖模块

- 3、**模块解析** （从入口模块开始递归分析依赖（构建模块依赖图））
  - 每个模块通过 Webpack 内部的模块解析器处理路径
  - 如果遇到非 JS 模块（比如 `.css`, `.vue`），会用对应的 **Loader** 处理
- 4、**使用 Loader 转换模块**（使用 Loader 转换模块（如 .vue、.ts、.scss））
  - Loader 本质是函数
  - 会将源文件转换为 JS 模块`（比如把 SCSS → CSS → JS 注入）`
- 5、**调用 Plugin 插入构建生命周期钩子**（调用 Plugin 执行构建过程中的钩子（如生成 html））
  - Webpack 提供生命周期钩子（如：`compile`, `emit`, `done`）
  - 插件（如 `HtmlWebpackPlugin`, `DefinePlugin`）在合适阶段执行
- 6、**输出文件（Emit）**（将模块打包成一个或多个 bundle 输出到指定位置（output））
  - 根据入口和依赖关系，打包成 bundle
  - 输出到 `output.path` 指定的目录，生成最终的资源文件（JS、HTML、CSS 等）

---

#### Vite 打包原理

> Vite 在开发时使用原生 ESM 实现极速热更新，在生产构建时基于 Rollup 打包优化生成最终资源。

| 阶段         | 技术底层           | 作用                               |
| ------------ | ------------------ | ---------------------------------- |
| **开发阶段** | 原生 ESM + esbuild | 快速启动、模块按需加载、秒级热更新 |
| **打包阶段** | Rollup             | 打包优化、Tree Shaking、代码压缩   |

- 1、**读取配置** （读取 vite.config.js 配置）
  - Vite 加载 `vite.config.js`，合并默认配置
  - 内部封装 Rollup 打包选项
- 2、**构建模块依赖图**（entry（如 index.html 或 main.ts）为起点解析模块依赖图）
          - 从入口（通常是 `index.html` 中的 `<script type="module">`）开始
          - 递归地追踪所有模块（ESM 格式）
- 3、**插件运行**（使用插件体系（Vite 插件 + Rollup 插件）处理模块转换）
   	- 执行 Vite 和 Rollup 插件链（包括 `vite:xxx`, `rollup:xxx`）
   	- 转换文件格式（如 `.ts`、`.vue`、`.scss` 等）
- 4、**优化处理**（Rollup 对模块进行 Tree Shaking、分块（chunk）、压缩等优化）
  - Rollup执行
    - Tree Shaking（移除未使用代码）
    - 分块（code splitting）
    - 动态导入分析
    - 静态资源处理（如图片、SVG）
- 5、**输出资源**（输出静态资源到 dist 目录（如 JS、CSS、Assets））
  - 所有资源写入到 `dist/`
    - JS：合并、分块、压缩后的 bundle
    - CSS：提取并合并后的样式文件
    - Assets：拷贝静态资源（图片、字体等）

---

#### Vite与Webpack打包对比总结

| 对比项       | Vite（生产）                     | Webpack            |
| ------------ | -------------------------------- | ------------------ |
| 打包工具     | ✅ Rollup                         | ✅ Webpack 自身     |
| Tree Shaking | ✅ 极致优化                       | ✅ 一般             |
| 代码分块     | ✅ 更智能                         | ✅ 支持             |
| 插件机制     | ✅ Rollup 插件 + 自定义 Vite 插件 | ✅ Webpack 插件体系 |
| 配置灵活性   | 高（可继承 Rollup）              | 高                 |
| 静态资源处理 | 内置支持 + plugin                | 需配置 loader      |

---

#### Webpack为什么启动慢？

> Webpack 启动慢，是因为它需要构建完整的模块图、转换文件、执行插件，并做构建优化；优化关键在于**缓存、并发、多进程、减少无效构建**。

- 1、**从入口构建“模块依赖图”耗时**
  - Webpack 会从 `entry` 入口递归查找所有依赖模块
  - 每一个 `import` 都要解析路径、读取文件、分析语法
  - 对于大型项目，模块数量可能上千，构建依赖图非常耗时
- 2、 **使用大量 Loader 转换模块（如 Babel）**
  	- Loader 如 `babel-loader`, `ts-loader`, `vue-loader` 会把源码编译成 JS
  - 特别是 Babel 转换会涉及 AST 抽象语法树解析与重构，CPU 密集型操作
  - 比如一个 React 项目可能 Babel 转换几百个 `.jsx` 文件
- 3、**Plugin 插件执行耗时**
  - 插件如 `HtmlWebpackPlugin`, `MiniCssExtractPlugin`, `TerserWebpackPlugin`
  - 会在构建生命周期钩子中进行各种复杂操作（比如压缩、分析、提取 CSS）
  - 一些插件可能同步读写文件、生成中间代码、甚至调用子进程
- 4、**文件 I/O 频繁（尤其是磁盘读取）**
  - 需要访问大量源文件（源码、依赖库、样式、资源等）
  - 文件读取通常是同步进行的（尤其是 Windows 系统或慢磁盘）
- 5、 **缺少缓存（每次都是全量构建）**
  - 没有开启 `cache: true`、`babel-loader` 的缓存、`hard-source-webpack-plugin`
  - 每次启动都重新分析和转换模块，造成冗余计算
- 6、**构建优化开销大（特别是生产模式）**
  - 如启用了代码压缩（Terser）、Tree Shaking、scope hoisting、chunk split 等
  - 对构建时间要求极高，特别是压缩 JS 的过程很慢（AST 层面压缩）

---

#### loader 和 plugin的区别？

- **Loader**：是“文件【转换器】”
- **Plugin**：是“构建过程的钩子【扩展器】”

| 名称       | 用途                                                         |
| ---------- | ------------------------------------------------------------ |
| **Loader** | 让 Webpack 能“理解并处理”各种非 JS 文件，比如 `.vue`、`.scss`、`.ts` |
| **Plugin** | 用于在 Webpack 构建生命周期中做“更复杂的事”，比如压缩代码、自动生成 HTML、定义环境变量等 |

| 对比项   | Loader           | Plugin                  |
| -------- | ---------------- | ----------------------- |
| 作用范围 | 处理单个文件内容 | 参与整个构建流程        |
| 类型     | 函数             | 类，必须有 `apply` 方法 |
| 使用位置 | `module.rules`   | `plugins`               |
| 应用时机 | 模块加载时       | 构建生命周期的不同阶段  |
| 使用方式 | 逐个链式调用     | 实例化后放入插件数组    |